// Данные для каждого задания
const tasksData = {
    1: {
        title: "Задание 1",
        description: "Я очень надеюсь, что ты не будешь решать это задание кодом",
        code: null
    },
    2: {
        title: "Задание 2",
        description: "Решение задачи с помощью Python",
        code: `from itertools import *

def f(x,y,w,z):
 # Переписываем условие тут 
    return (z==(not x))<=((w<=(not y))and(y<=x))

for a1,a2,a3,a4,a5 in product([0,1], repeat=5):
#вот тут надо переписать таблицу
    t = [(1,1,1,0), (a1,a2,0,0), (a3,0,a4,a5)]
    if len(set(t))==3:
        for p in permutations('xywz'):
            if [f(**dict(zip(p,r))) for r in t]==[1,0,0]: # тут тоже не забываем
                print(p)`
    },
    3: {
        title: "Задание 3",
        description: "Тут я тебе никак не помогу",
        code: null
    },
    4: {
        title: "Задание 4",
        description: "Это надо уметь решать",
        code: null
    },
    5: {
        title: "Задание 5",
        description: "Почти универсальный код для 5",
        task: `На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
1. Строится запись числа N в системе счисления с основанием 12.
2. Далее эта запись обрабатывается по следующему правилу:
а) если число N делится на 3, то слева к нему приписывается «1», а справа «B»;
б) если число N на 3 не делится, то слева к нему приписывается «2», а справа «0». Полученная таким образом запись является двенадцатеричной записью искомого числа R. 3. Результат переводится в десятичную систему и выводится на экран.
Например, для исходного числа 11 = B12 результатом является число 2B012= 420, а для исходного числа 12 = 1012 это число 110B12 = 1883.
Укажите максимальное число R, меньшее 1996, которое может быть получено с помощью описанного алгоритма. В ответе запишите это число в десятичной системе счисления.`,
        code: `from string import *
#переводим в нужную систему, тут можно хоть в 2 чтобы мозги не манать
def s12(x):
    if x==0: return '0'
    s = ''
    while x>0:
        s = printable[x%12]+s
        x//=12
    return s

m = []
#перебираем учитывая условие
for n in range(1,2000):
    b = s12(n)
#это уже пишем строго по условию
    if n%3==0:
        b = '1'+b+'B'
    else:
        b = '2'+b+'0'
    r = int(b,12)
#условие - меньше 1996, но максимальное, значит нужен список куда добавим все и после выведем максимальное
    if r<1996:
        m.append(r)
print(max(m))
#если бы нужное было минимальное, то просто break`
    },
    6: {
        title: "Задание 6",
        description: "С помощью пайтона также",
        task: `Черепаха выполнила следующую программу:
Повтори 2 [Вперёд 24 Направо 90 Вперёд 10 Направо 90]
Вперёд 3 Налево 90 Вперёд 13 Направо 90
Повтори 2 [Вперёд 9 Направо 90 Вперёд 32 Направо 90]
Полученный при выполнении этой программы рисунок можно рассматривать как набор непересекающихся прямоугольников. Определите наибольшую из площадей этих прямоугольников. В ответе запишите только число – наибольшую площадь в условных единицах`,
        code: `#вот это база, везде также пишем
from turtle import *
tracer(0)
screensize(10000,10000)
r = 20
#вот это уже зависит от условия задачи
for i in range(2):
 # Двигаемся вперёд на 24 единицы, поворачиваем направо на 90 градусов
    fd(24*r)
 # двигаемся вперёд на 10 единиц, снова поворачиваем направо на 90 градусов
    rt(90)
    fd(10*r)
    rt(90)
 # двигаемся вперёд на 3 единицы, поворачиваем налево на 90 градусов
fd(3*r)
lt(90)
# двигаемся вперёд на 13 единиц, поворачиваем направо на 90 градусов
fd(13*r)
rt(90)
for i in range(2):
    fd(9*r)
    rt(90)
    fd(32*r)
    rt(90)
up()
#Создаём точечки, это тоже одна из баз
for x in range(-50,50):
    for y in range(-50,50):
 # Перемещаемся к координатам (x*r, y*r)
        goto(x*r,y*r)
 # Рисуем красную точку радиусом 4 пикселя
        dot(4,'red')
update()`,
        additionalCode: `#дополнительный код с canvas
#в душе не чаю как этим пользоваться, но умным понадобится вдруг
from turtle import *

left(90)
speed(10)
l = 20

begin_fill()
for i in range(8):
forward(6*l)
right(120)
end_fill()

canvas = getcanvas()
count = 0
for x in range(-100*l, 100*l, l):
for y in range(-100*l, 100*l, l):
item = canvas.find_overlapping(x, y, x, y)
if len(item) == 1 and item[0] == 5:
count += 1
print(count)

done()`
    },
    7: {
        title: "Задание 7",
        description: "Это решаем либо руками, либо простым циклом",
        code: null
    },
    8: {
        title: "Задание 8",
        description: "Простейшее задание, вот некоторые коды для него",
        task: `Все шестибуквенные слова, составленные из букв С, О, Л, Н, Ц, Е, записаны в алфавитном порядке и пронумерованы. Ниже приведено начало списка.
1. ЕЕЕЕЕЕ
2. ЕЕЕЕЕЛ
3. ЕЕЕЕЕН
4. ЕЕЕЕЕО
5. ЕЕЕЕЕС
6. ЕЕЕЕЕЦ
Определите в этом списке количество слов с чётными номерами, которые не начинаются с гласной буквы и при этом содержат в своей записи ровно две буквы Ц.`,
        code: `from itertools import *
 #два счетчика нужны из за условия
k = 0
k2 = 0

for x in product('ЕЛНОСЦ',repeat=6):
    s = ''.join(x)
    k += 1
#это мы делаем учитывая условие
    if k%2==0 and s[0] not in 'ЕО' and s.count('Ц')==2:
        k2 += 1
print(k2)`,
        additionalTask: `Аня составляет слова, переставляя буквы в слове ОДЕКОЛОН, избегая слов, где соседние буквы — одинаковые. Сколько различных слов, включая исходное, может составить Аня?`,
        additionalCode: `from itertools import *
 #тут уже один счетчик
k = 0

for x in set(permutations('ОДЕКОЛОН')):
    s = ''.join(x)
#ну условие тут легкое
    if 'ОО' not in s:
        k += 1
print(k)`
    },
    9: {
        title: "Задание 9",
        description: "Это задание делаем через питон, хоть можно и через таблицы",
        task: `В каждой строке электронной таблицы записаны шесть целых чисел. Определите, сколько в таблице строк, для которых выполнены следующие условия:
– в строке есть как повторяющиеся, так и неповторяющиеся числа;
– среднее арифметическое всех неповторяющихся чисел строки меньше, чем среднее арифметическое всех повторяющихся чисел этой строки.
При вычислении средних значений каждое число учитывается столько раз, сколько оно встречается в строке. В ответе запишите число – количество строк, для которых выполнены эти условия.`,
        code: `k = 0
 #перед этим надо создать тхт файл с числами под названием 9
for s in open('9.txt'):
#это условие база - переводит в нужный формат
    a = [int(x) for x in s.split()]
# это условие заносит в список только если число не повторяется
    a1 = [x for x in a if a.count(x)==1]
#это если повторяется
    a2 = [x for x in a if a.count(x)>1]
    if len(a1)>0 and len(a2)>0 and sum(a1)/len(a1) < sum(a2)/len(a2):
        k += 1
print(k)`
    },
    10: {
        title: "Задание 10",
        description: "Задание на знания поиска",
        code: null
    },
    11: {
        title: "Задание 11",
        description: "Тут делаем либо руками либо простым циклом с math",
        code: null
    },
    12: {
        title: "Задание 12",
        description: "Вообще решается аналитикой обычно, но есть код",
        code: `#словарь для машины тьюринга, страшная вещь
prog = {
    (' ',0): (' ',1,0),
    (' ',1): (' ',2,1),
    ('0',0): ('1',1,1),
    ('0',1): ('1',1,0),
    ('1',0): ('0',1,1),
    ('1',1): ('0',1,0),
    ('2',0): ('1',2,0),
    ('2',1): ('0',2,1)
    }
#симуляция ее работы
def mt(s):
    s = list(' '+s+' ')
    i = 0
    q = 0
    while True:
        cmd = prog[(s[i],q)]
        s[i] = cmd[0]
        if cmd[1]==2: break
        i += cmd[1]
        q = cmd[2]
    return ''.join(s)
 #это переписываем само условие
res = mt(750*'1'+650*'0'+'2')
print(res.count('1'))
#и все, задание решается за тебя`
    },
    13: {
        title: "Задание 13",
        description: "Прототипов много, надеюсь нашел все",
        tasks: [
            {
                text: `В терминологии сетей TCP/IP маска сети – это двоичное число, меньшее 232; в маске сначала (в старших разрядах) стоят единицы, а затем с некоторого места нули. Маска определяет, какая часть IP-адреса узла сети относится к адресу сети, а какая – к адресу самого узла в этой сети. Обычно маска записывается по тем же правилам, что и IP-адрес – в виде четырёх байт, причём каждый байт записывается в виде десятичного числа. Адрес сети получается в результате применения поразрядной конъюнкции к заданному IP-адресу узла и маске.
Для узла с IP-адресом 241.185.253.57 адрес сети равен 241.185.252.0. Найдите наименьшее возможное количество нулей в двоичной записи маски подсети.`,
                code: `from ipaddress import *

for mask in range(33):
    net = ip_network(f'241.185.253.57/{mask}',0)
    print(net, 32-mask) #тут мы вычли чтобы найти количество нулей, если что
#этот код выводит все айпи и нужно по условию задачи найти минимальное кол-во нулей`
            },
            {
                text: `В терминологии сетей TCP/IP маска сети – это двоичное число, меньшее 232; в маске сначала (в старших разрядах) стоят единицы, а затем с некоторого места нули. Маска определяет, какая часть IP-адреса узла сети относится к адресу сети, а какая – к адресу самого узла в этой сети. Обычно маска записывается по тем же правилам, что и IP-адрес – в виде четырёх байт, причём каждый байт записывается в виде десятичного числа. Адрес сети получается в результате применения поразрядной конъюнкции к заданному IP-адресу узла и маске.
Для узла с IP-адресом 108.133.75.91 адрес сети равен 108.133.75.64. Чему равно наибольшее количество возможных адресов в этой сети?`,
                code: `from ipaddress import *

for mask in range(33):
    net = ip_network(f'108.133.75.91/{mask}',0)
    print(net, 2**(32-mask)) #возвели 2 в маску чтобы получить количество адресов`
            },
            {
                text: `В терминологии сетей ТСР/IР маской сети называют двоичное число, которое показывает, какая часть IP-адреса узла сети относится к адресу сети, а какая - к адресу узла в этой сети. Адрес сети получается в результате применения поразрядной конъюнкции к заданному адресу узла и его маске. Широковещательным адресом называется специализированный адрес, в котором на месте нулей в маске стоят единицы. Адрес сети и широковещательный адрес не могут быть использованы для адресации сетевых устройств.
Сеть задана IP-адресом одного из входящих в неё узлов 102.162.200.51 и сетевой маской 255.255.255.0.
Найдите в данной сети наибольший IP-адрес, который может быть назначен компьютеру. В ответе укажите сумму числовых значений октетов найденного IP-адреса.`,
                code: `from ipaddress import *

net = ip_network('102.162.200.51/255.255.255.0',0)
 #нужен наибольший, но для компа, поэтому предпоследний
print(net[-2])`
            },
            {
                text: `В терминологии сетей TCP/IP маской сети называют двоичное число, которое показывает, какая часть IP-адреса узла сети относится к адресу сети, а какая – к адресу узла в этой сети. Адрес сети получается в результате применения поразрядной конъюнкции к заданному адресу узла и его маске.
Широковещательным адресом называется специализированный адрес, в котором на месте нулей в маске стоят единицы. Адрес сети и широковещательный адрес не могут быть использованы для адресации сетевых устройств.
Сеть задана IP-адресом одного из входящих в неё узлов 192.168.12.207 и сетевой маской 255.192.0.0.
Найдите наибольший в данной сети IP-адрес, в котором одинаковое количество нулей и единиц в двоичной записи. В ответе укажите найденный IP-адрес без пробелов и разделителей`,
                code: `from ipaddress import *

net = ip_network('192.168.12.207/255.192.0.0',0)

m = []

for ip in net:
    b = f'{ip:b}'
    if b.count('0')==b.count('1'):
        m.append(ip)
print(m[-1])`
            },
            {
                text: `В терминологии сетей TCP/IP маской сети называют двоичное число, которое показывает, какая часть IP-адреса узла сети относится к адресу сети, а какая – к адресу узла в этой сети. Адрес сети получается в результате применения поразрядной конъюнкции к заданному адресу узла и маске сети.
Сеть, в которой содержится узел с IP-адресом 207.0.A.167, задана маской сети 255.255.255.192, где A - некоторое допустимое для записи IP-адреса число. Определите количество значений A, для которых для всех IP-адресов этой сети в двоичной записи IP-адреса суммарное количество нулей в левых двух байтах больше суммарного количества нулей в правых двух байтах.`,
                code: `from ipaddress import *
 #функция для определения нужного айпи по условию
def check(ip):
    b = f'{ip:b}'
    l = b[:16]
    r = b[16:]
    return l.count('0')>r.count('0')

k = 0
for a in range(256):
    net = ip_network(f'207.0.{a}.167/255.255.255.192',0)
#проверим чтобы во всех айпи выполнялось функция
    if all(check(ip)==1 for ip in net):
        k += 1
print(k)`
            }
        ]
    }
};

// Заполняем данные для всех 27 заданий
for (let i = 14; i <= 27; i++) {
    tasksData[i] = {
        title: `Задание ${i}`,
        description: `Здесь будет описание задания ${i}`,
        code: null
    };
}

// Функция копирования кода
function copyCode(button, codeId) {
    const codeBlock = document.getElementById(codeId);
    const code = codeBlock.textContent;

    navigator.clipboard.writeText(code).then(() => {
        button.textContent = '✓ Скопировано';
        button.classList.add('copied');

        setTimeout(() => {
            button.textContent = 'Копировать';
            button.classList.remove('copied');
        }, 2000);
    }).catch(err => {
        console.error('Ошибка копирования:', err);
        button.textContent = '✗ Ошибка';
        setTimeout(() => {
            button.textContent = 'Копировать';
        }, 2000);
    });
}

// Функция открытия задания
function openTask(taskNumber) {
    const content = document.getElementById('content');
    const task = tasksData[taskNumber];

    // Убираем активный класс со всех кнопок
    document.querySelectorAll('.task-btn').forEach(btn => {
        btn.classList.remove('active');
    });

    // Добавляем активный класс к выбранной кнопке
    document.querySelectorAll('.task-btn')[taskNumber - 1].classList.add('active');

    // Формируем HTML с текстом задачи, если он есть
    let taskHTML = '';
    if (task.task) {
        taskHTML = `
            <div class="task-box">
                <h3>Текст задачи</h3>
                <p>${task.task.replace(/\n/g, '<br>')}</p>
            </div>
        `;
    }

    // Формируем HTML с кодом, если он есть
    let codeHTML = '';
    if (task.code) {
        codeHTML = `
            <div class="code-container">
                <div class="code-header">
                    <span>Python</span>
                    <button class="copy-btn" onclick="copyCode(this, 'code-${taskNumber}')">Копировать</button>
                </div>
                <div class="code-block">
                    <pre id="code-${taskNumber}">${task.code}</pre>
                </div>
            </div>
        `;
    }

    // Формируем HTML с дополнительной задачей, если она есть
    let additionalTaskHTML = '';
    if (task.additionalTask) {
        additionalTaskHTML = `
            <div class="task-box">
                <h3>Другая задача</h3>
                <p>${task.additionalTask.replace(/\n/g, '<br>')}</p>
            </div>
        `;
    }

    // Формируем HTML с дополнительным кодом, если он есть
    let additionalCodeHTML = '';
    if (task.additionalCode) {
        additionalCodeHTML = `
            <div class="code-container">
                <div class="code-header">
                    <span>Python${task.additionalTask ? '' : ' (дополнительный код)'}</span>
                    <button class="copy-btn" onclick="copyCode(this, 'code-additional-${taskNumber}')">Копировать</button>
                </div>
                <div class="code-block">
                    <pre id="code-additional-${taskNumber}">${task.additionalCode}</pre>
                </div>
            </div>
        `;
    }

    // Формируем HTML с множественными задачами (для задания 13)
    let tasksHTML = '';
    if (task.tasks) {
        tasksHTML = task.tasks.map((item, index) => `
            <div class="task-box">
                <h3>Задача ${index + 1}</h3>
                <p>${item.text.replace(/\n/g, '<br>')}</p>
            </div>
            <div class="code-container">
                <div class="code-header">
                    <span>Python</span>
                    <button class="copy-btn" onclick="copyCode(this, 'code-${taskNumber}-${index}')">Копировать</button>
                </div>
                <div class="code-block">
                    <pre id="code-${taskNumber}-${index}">${item.code}</pre>
                </div>
            </div>
        `).join('');
    }

    // Отображаем содержимое задания
    content.innerHTML = `
        <div class="task-content">
            <div class="task-header">
                <h2>${task.title}</h2>
            </div>

            <div class="task-description">
                <h3>Пояснение</h3>
                <p>${task.description}</p>
            </div>

            ${taskHTML}
            ${codeHTML}
            ${additionalTaskHTML}
            ${additionalCodeHTML}
            ${tasksHTML}
        </div>
    `;

    // Плавная прокрутка наверх
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

// Функция возврата к главной странице
function goBack() {
    const content = document.getElementById('content');

    // Убираем активный класс со всех кнопок
    document.querySelectorAll('.task-btn').forEach(btn => {
        btn.classList.remove('active');
    });

    content.innerHTML = `
        <div class="welcome">
            <h2>Дарова</h2>
            <p>Сверху номера заданий, жми и получай код</p>
        </div>
    `;
}
